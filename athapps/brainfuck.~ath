// =============================================================================
// Brainfuck Interpreter in !~ATH
// =============================================================================
// An interpreter for the Brainfuck esoteric programming language.
// Uses CODE() and CHAR() builtins for character/codepoint conversion,
// and bitwise & for byte wrapping.
//
// Usage: Call runBrainfuck(code, input) where:
//   - code: string of Brainfuck commands (+-[]<>.,)
//   - input: string of input to the program
//
// The interpreter outputs the result via UTTER when execution completes.
// =============================================================================

// --- Global State ---
// All interpreter state is stored globally so async operations can access it

BIRTH G_code WITH "";
BIRTH G_input WITH "";
BIRTH G_tape WITH [];
BIRTH G_ptr WITH 0;
BIRTH G_ip WITH 0;
BIRTH G_inputPos WITH 0;
BIRTH G_output WITH "";
BIRTH G_brackets WITH {};
BIRTH G_bracketStack WITH [];
BIRTH G_bracketIdx WITH 0;

// --- Tape Operations ---
// Arrays are immutable in !~ATH, so we need to create new arrays for modifications

RITE setCell(tape, idx, val) {
    BEQUEATH CONCAT(
        CONCAT(SLICE(tape, 0, idx), [val]),
        SLICE(tape, idx + 1, LENGTH(tape))
    );
}

RITE incCell(tape, ptr) {
    BIRTH val WITH tape[ptr];
    BIRTH newVal WITH (val + 1) & 255;
    BEQUEATH setCell(tape, ptr, newVal);
}

RITE decCell(tape, ptr) {
    BIRTH val WITH tape[ptr];
    BIRTH newVal WITH (val + 255) & 255;
    BEQUEATH setCell(tape, ptr, newVal);
}

// --- Tape Initialization ---
// Build tape in chunks using timer-chained recursion to avoid stack overflow

ENTOMB TAPE_CHUNK WITH [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

BIRTH G_tapeChunksLeft WITH 0;

RITE buildTapeStep() {
    SHOULD G_tapeChunksLeft > 0 {
        G_tape = CONCAT(G_tape, TAPE_CHUNK);
        G_tapeChunksLeft = G_tapeChunksLeft - 1;
        import timer T(1);
        ~ATH(!T) { } EXECUTE(buildTapeStep());
    } LEST {
        // Tape complete, start bracket building
        buildBracketsStep();
    }
}

// --- Bracket Matching (Async) ---
// Pre-compute matching brackets using timer-chained recursion

RITE buildBracketsStep() {
    BIRTH len WITH LENGTH(G_code);

    SHOULD G_bracketIdx < len {
        BIRTH char WITH G_code[G_bracketIdx];

        SHOULD char == "[" {
            G_bracketStack = APPEND(G_bracketStack, G_bracketIdx);
        } LEST SHOULD char == "]" {
            SHOULD LENGTH(G_bracketStack) == 0 {
                CONDEMN "Unmatched ] at position " + STRING(G_bracketIdx);
            }
            BIRTH openPos WITH LAST(G_bracketStack);
            G_bracketStack = SLICE(G_bracketStack, 0, LENGTH(G_bracketStack) - 1);
            G_brackets = SET(G_brackets, STRING(openPos), G_bracketIdx);
            G_brackets = SET(G_brackets, STRING(G_bracketIdx), openPos);
        }

        G_bracketIdx = G_bracketIdx + 1;

        import timer T(1);
        ~ATH(!T) { } EXECUTE(buildBracketsStep());
    } LEST {
        SHOULD LENGTH(G_bracketStack) > 0 {
            CONDEMN "Unmatched [ at position " + STRING(FIRST(G_bracketStack));
        }
        // Bracket map complete, start execution
        startExecution();
    }
}

// --- Core Execution ---
// Main execution loop using timer-chained recursion

RITE startExecution() {
    G_ptr = 0;
    G_ip = 0;
    G_inputPos = 0;
    G_output = "";
    runStep();
}

RITE runStep() {
    BIRTH len WITH LENGTH(G_code);

    // Check if execution is complete
    SHOULD G_ip >= len {
        UTTER(G_output);
        BEQUEATH VOID;
    }

    BIRTH cmd WITH G_code[G_ip];

    SHOULD cmd == "+" {
        G_tape = incCell(G_tape, G_ptr);
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "-" {
        G_tape = decCell(G_tape, G_ptr);
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == ">" {
        G_ptr = G_ptr + 1;
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "<" {
        G_ptr = G_ptr - 1;
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "." {
        G_output = G_output + CHAR(G_tape[G_ptr]);
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "," {
        SHOULD G_inputPos < LENGTH(G_input) {
            G_tape = setCell(G_tape, G_ptr, CODE(G_input[G_inputPos]));
            G_inputPos = G_inputPos + 1;
        } LEST {
            G_tape = setCell(G_tape, G_ptr, 0);
        }
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "[" {
        SHOULD G_tape[G_ptr] == 0 {
            G_ip = G_brackets[STRING(G_ip)] + 1;
        } LEST {
            G_ip = G_ip + 1;
        }
    } LEST SHOULD cmd == "]" {
        SHOULD G_tape[G_ptr] != 0 {
            G_ip = G_brackets[STRING(G_ip)] + 1;
        } LEST {
            G_ip = G_ip + 1;
        }
    } LEST {
        // Unknown character, skip
        G_ip = G_ip + 1;
    }

    // Timer-chain to next step (prevents stack overflow)
    import timer T(1);
    ~ATH(!T) { } EXECUTE(runStep());
}

// --- Main Entry Point ---

RITE runBrainfuck(code, input) {
    // Initialize global state
    G_code = code;
    G_input = input;
    G_tape = [];
    G_brackets = {};
    G_bracketStack = [];
    G_bracketIdx = 0;

    // Build tape (300 chunks of 100 = 30000 cells)
    G_tapeChunksLeft = 300;
    buildTapeStep();
}

// =============================================================================
// Test Cases - Uncomment one to run
// =============================================================================

// Test 1: Hello World (no input, outputs "Hello World!")
//runBrainfuck(
//    "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.",
//    ""
// );

// Test 2: Output digits 0-9 (no input, outputs "0123456789")
// runBrainfuck(
//     "++++++++[->+>++++++<<]>++[->.+<]",
//     ""
// );

// Test 3: Cat program (echoes input)
// runBrainfuck(
//     ",[.,]",
//     "Hello, World!"
// );

// Test 4: Prime sieve (input: number followed by newline, outputs primes up to that number)
// runBrainfuck(
//     ">++++++++[<++++++++>-]<++++++++++++++++.[-]>++++++++++[<++++++++++>-]<++++++++++++++.[-]>++++++++++[<++++++++++>-]<+++++.[-]>++++++++++[<++++++++++>-]<+++++++++.[-]>++++++++++[<++++++++++>-]<+.[-]>++++++++++[<++++++++++>-]<+++++++++++++++.[-]>+++++[<+++++>-]<+++++++.[-]>++++++++++[<++++++++++>-]<+++++++++++++++++.[-]>++++++++++[<++++++++++>-]<++++++++++++.[-]>+++++[<+++++>-]<+++++++.[-]>++++++++++[<++++++++++>-]<++++++++++++++++.[-]>++++++++++[<++++++++++>-]<+++++++++++.[-]>+++++++[<+++++++>-]<+++++++++.[-]>+++++[<+++++>-]<+++++++.[-]+[->,----------[<+>-------------------------------------->[>+>+<<-]>>[<<+>>-]<>>>+++++++++[<<<[>+>+<<-]>>[<<+>>-]<[<<+>>-]>>-]<<<[-]<<[>+<-]]<]>>[<<+>>-]<<>+<-[>+[>+>+<<-]>>[<<+>>-]<>+<-->>>>>>>>+<<<<<<<<[>+<-<[>>>+>+<<<<-]>>>>[<<<<+>>>>-]<<<>[>>+>+<<<-]>>>[<<<+>>>-]<<<<>>>[>+>+<<-]>>[<<+>>-]<<<[>>>>>+<<<[>+>+<<-]>>[<<+>>-]<[>>[-]<<-]>>[<<<<[>+>+<<-]>>[<<+>>-]<>>>-]<<<-<<-]+>>[<<[-]>>-]<<>[-]<[>>>>>>[-]<<<<<<-]<<>>[-]>[-]<<<]>>>>>>>>[-<<<<<<<[-]<<[>>+>+<<<-]>>>[<<<+>>>-]<<<>>[>+<-]>[[>+>+<<-]>>[<<+>>-]<>+++++++++<[>>>+<<[>+>[-]<<-]>[<+>-]>[<<++++++++++>>-]<<-<-]+++++++++>[<->-]<[>+<-]<[>+<-]<[>+<-]>>>[<<<+>>>-]<>+++++++++<[>>>+<<[>+>[-]<<-]>[<+>-]>[<<++++++++++>>>+<-]<<-<-]>>>>[<<<<+>>>>-]<<<<>[-]<<+>]<[[>+<-]+++++++[<+++++++>-]<-><.[-]>>[<<+>>-]<<-]>++++[<++++++++>-]<.[-]>>>>>>>]<<<<<<<<>[-]<[-]<<-]++++++++++.[-]",
//     "20\n"
// );

THIS.DIE();
