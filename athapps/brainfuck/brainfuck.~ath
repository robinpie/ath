// =============================================================================
// Brainfuck Interpreter in !~ATH
// =============================================================================
// An interpreter for the Brainfuck esoteric programming language, implemented
// in !~ATH (another esoteric language where control flow is predicated on death).
//
// Usage: Call runBrainfuck(code, input) where:
//   - code: string of Brainfuck commands (+-[]<>.,)
//   - input: string of ASCII input to the program
//
// The interpreter outputs the result via UTTER when execution completes.
// =============================================================================

// --- ASCII Lookup Tables ---
// !~ATH has no built-in chr/ord, so we need explicit mappings

ENTOMB CHAR_TO_CODE WITH {
    "\n": 10, "\t": 9,
    " ": 32, "!": 33, "\"": 34, "#": 35, "$": 36, "%": 37, "&": 38, "'": 39,
    "(": 40, ")": 41, "*": 42, "+": 43, ",": 44, "-": 45, ".": 46, "/": 47,
    "0": 48, "1": 49, "2": 50, "3": 51, "4": 52, "5": 53, "6": 54, "7": 55,
    "8": 56, "9": 57, ":": 58, ";": 59, "<": 60, "=": 61, ">": 62, "?": 63,
    "@": 64, "A": 65, "B": 66, "C": 67, "D": 68, "E": 69, "F": 70, "G": 71,
    "H": 72, "I": 73, "J": 74, "K": 75, "L": 76, "M": 77, "N": 78, "O": 79,
    "P": 80, "Q": 81, "R": 82, "S": 83, "T": 84, "U": 85, "V": 86, "W": 87,
    "X": 88, "Y": 89, "Z": 90, "[": 91, "\\": 92, "]": 93, "^": 94, "_": 95,
    "`": 96, "a": 97, "b": 98, "c": 99, "d": 100, "e": 101, "f": 102, "g": 103,
    "h": 104, "i": 105, "j": 106, "k": 107, "l": 108, "m": 109, "n": 110, "o": 111,
    "p": 112, "q": 113, "r": 114, "s": 115, "t": 116, "u": 117, "v": 118, "w": 119,
    "x": 120, "y": 121, "z": 122, "{": 123, "|": 124, "}": 125, "~": 126
};

// Code to character mapping (keys must be strings for map lookup)
ENTOMB CODE_TO_CHAR WITH {
    "10": "\n", "9": "\t",
    "32": " ", "33": "!", "34": "\"", "35": "#", "36": "$", "37": "%", "38": "&", "39": "'",
    "40": "(", "41": ")", "42": "*", "43": "+", "44": ",", "45": "-", "46": ".", "47": "/",
    "48": "0", "49": "1", "50": "2", "51": "3", "52": "4", "53": "5", "54": "6", "55": "7",
    "56": "8", "57": "9", "58": ":", "59": ";", "60": "<", "61": "=", "62": ">", "63": "?",
    "64": "@", "65": "A", "66": "B", "67": "C", "68": "D", "69": "E", "70": "F", "71": "G",
    "72": "H", "73": "I", "74": "J", "75": "K", "76": "L", "77": "M", "78": "N", "79": "O",
    "80": "P", "81": "Q", "82": "R", "83": "S", "84": "T", "85": "U", "86": "V", "87": "W",
    "88": "X", "89": "Y", "90": "Z", "91": "[", "92": "\\", "93": "]", "94": "^", "95": "_",
    "96": "`", "97": "a", "98": "b", "99": "c", "100": "d", "101": "e", "102": "f", "103": "g",
    "104": "h", "105": "i", "106": "j", "107": "k", "108": "l", "109": "m", "110": "n", "111": "o",
    "112": "p", "113": "q", "114": "r", "115": "s", "116": "t", "117": "u", "118": "v", "119": "w",
    "120": "x", "121": "y", "122": "z", "123": "{", "124": "|", "125": "}", "126": "~"
};

// --- Global State ---
// All interpreter state is stored globally so async operations can access it

BIRTH G_code WITH "";
BIRTH G_input WITH "";
BIRTH G_tape WITH [];
BIRTH G_ptr WITH 0;
BIRTH G_ip WITH 0;
BIRTH G_inputPos WITH 0;
BIRTH G_output WITH "";
BIRTH G_brackets WITH {};
BIRTH G_bracketStack WITH [];
BIRTH G_bracketIdx WITH 0;
BIRTH G_tapeChunksLeft WITH 0;

// --- Tape Operations ---
// Arrays are immutable in !~ATH, so we need to create new arrays for modifications

RITE setCell(tape, idx, val) {
    BEQUEATH CONCAT(
        CONCAT(SLICE(tape, 0, idx), [val]),
        SLICE(tape, idx + 1, LENGTH(tape))
    );
}

RITE incCell(tape, ptr) {
    BIRTH val WITH tape[ptr];
    BIRTH newVal WITH (val + 1) % 256;
    BEQUEATH setCell(tape, ptr, newVal);
}

RITE decCell(tape, ptr) {
    BIRTH val WITH tape[ptr];
    BIRTH newVal WITH (val + 255) % 256;
    BEQUEATH setCell(tape, ptr, newVal);
}

// --- Tape Initialization ---
// Build tape in chunks using timer-chained recursion to avoid stack overflow

ENTOMB TAPE_CHUNK WITH [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

RITE buildTapeStep() {
    SHOULD G_tapeChunksLeft > 0 {
        G_tape = CONCAT(G_tape, TAPE_CHUNK);
        G_tapeChunksLeft = G_tapeChunksLeft - 1;
        import timer T(1);
        ~ATH(!T) { } EXECUTE(buildTapeStep());
    } LEST {
        // Tape complete, start bracket building
        buildBracketsStep();
    }
}

// --- Bracket Matching (Async) ---
// Pre-compute matching brackets using timer-chained recursion

RITE buildBracketsStep() {
    BIRTH len WITH LENGTH(G_code);

    SHOULD G_bracketIdx < len {
        BIRTH char WITH G_code[G_bracketIdx];

        SHOULD char == "[" {
            G_bracketStack = APPEND(G_bracketStack, G_bracketIdx);
        } LEST SHOULD char == "]" {
            SHOULD LENGTH(G_bracketStack) == 0 {
                CONDEMN "Unmatched ] at position " + STRING(G_bracketIdx);
            }
            BIRTH openPos WITH LAST(G_bracketStack);
            G_bracketStack = SLICE(G_bracketStack, 0, LENGTH(G_bracketStack) - 1);
            G_brackets = SET(G_brackets, STRING(openPos), G_bracketIdx);
            G_brackets = SET(G_brackets, STRING(G_bracketIdx), openPos);
        }

        G_bracketIdx = G_bracketIdx + 1;

        import timer T(1);
        ~ATH(!T) { } EXECUTE(buildBracketsStep());
    } LEST {
        SHOULD LENGTH(G_bracketStack) > 0 {
            CONDEMN "Unmatched [ at position " + STRING(FIRST(G_bracketStack));
        }
        // Bracket map complete, start execution
        startExecution();
    }
}

// --- Core Execution ---
// Main execution loop using timer-chained recursion

RITE startExecution() {
    G_ptr = 0;
    G_ip = 0;
    G_inputPos = 0;
    G_output = "";
    runStep();
}

RITE runStep() {
    BIRTH len WITH LENGTH(G_code);

    // Check if execution is complete
    SHOULD G_ip >= len {
        UTTER(G_output);
        BEQUEATH VOID;
    }

    BIRTH cmd WITH G_code[G_ip];

    SHOULD cmd == "+" {
        G_tape = incCell(G_tape, G_ptr);
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "-" {
        G_tape = decCell(G_tape, G_ptr);
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == ">" {
        G_ptr = G_ptr + 1;
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "<" {
        G_ptr = G_ptr - 1;
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "." {
        BIRTH cellVal WITH G_tape[G_ptr];
        BIRTH key WITH STRING(cellVal);
        SHOULD HAS(CODE_TO_CHAR, key) {
            G_output = G_output + CODE_TO_CHAR[key];
        } LEST {
            G_output = G_output + "?";
        }
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "," {
        SHOULD G_inputPos < LENGTH(G_input) {
            BIRTH inputChar WITH G_input[G_inputPos];
            SHOULD HAS(CHAR_TO_CODE, inputChar) {
                G_tape = setCell(G_tape, G_ptr, CHAR_TO_CODE[inputChar]);
            } LEST {
                G_tape = setCell(G_tape, G_ptr, 0);
            }
            G_inputPos = G_inputPos + 1;
        } LEST {
            G_tape = setCell(G_tape, G_ptr, 0);
        }
        G_ip = G_ip + 1;
    } LEST SHOULD cmd == "[" {
        SHOULD G_tape[G_ptr] == 0 {
            G_ip = G_brackets[STRING(G_ip)] + 1;
        } LEST {
            G_ip = G_ip + 1;
        }
    } LEST SHOULD cmd == "]" {
        SHOULD G_tape[G_ptr] != 0 {
            G_ip = G_brackets[STRING(G_ip)] + 1;
        } LEST {
            G_ip = G_ip + 1;
        }
    } LEST {
        // Unknown character, skip
        G_ip = G_ip + 1;
    }

    // Timer-chain to next step (prevents stack overflow)
    import timer T(1);
    ~ATH(!T) { } EXECUTE(runStep());
}

// --- Main Entry Point ---

RITE runBrainfuck(code, input) {
    // Initialize global state
    G_code = code;
    G_input = input;
    G_tape = [];
    G_brackets = {};
    G_bracketStack = [];
    G_bracketIdx = 0;

    // Build tape (300 chunks of 100 = 30000 cells)
    G_tapeChunksLeft = 300;
    buildTapeStep();
}

// =============================================================================
// Test Cases - Uncomment one to run
// =============================================================================

// Test 1: Hello World (no input, outputs "Hello World!")
runBrainfuck(
    "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.",
    ""
);

// Test 2: Output digits 0-9 (no input, outputs "0123456789")
// runBrainfuck(
//     "++++++++[->+>++++++<<]>++[->.+<]",
//     ""
// );

// Test 3: Cat program (echoes input)
// runBrainfuck(
//     ",[.,]",
//     "Hello, World!"
// );

// Test 4: Prime sieve (input: number followed by newline, outputs primes up to that number)
// runBrainfuck(
//     ">++++++++[<++++++++>-]<++++++++++++++++.[-]>++++++++++[<++++++++++>-]<++++++++++++++.[-]>++++++++++[<++++++++++>-]<+++++.[-]>++++++++++[<++++++++++>-]<+++++++++.[-]>++++++++++[<++++++++++>-]<+.[-]>++++++++++[<++++++++++>-]<+++++++++++++++.[-]>+++++[<+++++>-]<+++++++.[-]>++++++++++[<++++++++++>-]<+++++++++++++++++.[-]>++++++++++[<++++++++++>-]<++++++++++++.[-]>+++++[<+++++>-]<+++++++.[-]>++++++++++[<++++++++++>-]<++++++++++++++++.[-]>++++++++++[<++++++++++>-]<+++++++++++.[-]>+++++++[<+++++++>-]<+++++++++.[-]>+++++[<+++++>-]<+++++++.[-]+[->,----------[<+>-------------------------------------->[>+>+<<-]>>[<<+>>-]<>>>+++++++++[<<<[>+>+<<-]>>[<<+>>-]<[<<+>>-]>>-]<<<[-]<<[>+<-]]<]>>[<<+>>-]<<>+<-[>+[>+>+<<-]>>[<<+>>-]<>+<-->>>>>>>>+<<<<<<<<[>+<-<[>>>+>+<<<<-]>>>>[<<<<+>>>>-]<<<>[>>+>+<<<-]>>>[<<<+>>>-]<<<<>>>[>+>+<<-]>>[<<+>>-]<<<[>>>>>+<<<[>+>+<<-]>>[<<+>>-]<[>>[-]<<-]>>[<<<<[>+>+<<-]>>[<<+>>-]<>>>-]<<<-<<-]+>>[<<[-]>>-]<<>[-]<[>>>>>>[-]<<<<<<-]<<>>[-]>[-]<<<]>>>>>>>>[-<<<<<<<[-]<<[>>+>+<<<-]>>>[<<<+>>>-]<<<>>[>+<-]>[[>+>+<<-]>>[<<+>>-]<>+++++++++<[>>>+<<[>+>[-]<<-]>[<+>-]>[<<++++++++++>>-]<<-<-]+++++++++>[<->-]<[>+<-]<[>+<-]<[>+<-]>>>[<<<+>>>-]<>+++++++++<[>>>+<<[>+>[-]<<-]>[<+>-]>[<<++++++++++>>>+<-]<<-<-]>>>>[<<<<+>>>>-]<<<<>[-]<<+>]<[[>+<-]+++++++[<+++++++>-]<-><.[-]>>[<<+>>-]<<-]>++++[<++++++++>-]<.[-]>>>>>>>]<<<<<<<<>[-]<[-]<<-]++++++++++.[-]",
//     "20\n"
// );

THIS.DIE();
