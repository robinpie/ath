// Bitwise Operations Demo
// Demonstrates new bitwise operators and character conversion builtins

UTTER("Bitwise AND: 60 & 13 = " + STRING(60 & 13)); // 12
UTTER("Bitwise OR:  60 | 13 = " + STRING(60 | 13)); // 61
UTTER("Bitwise XOR: 60 ^ 13 = " + STRING(60 ^ 13)); // 49
UTTER("Bitwise NOT: ~60 = " + STRING(~60));         // -61
UTTER("Left Shift:  60 << 2 = " + STRING(60 << 2)); // 240
UTTER("Right Shift: 60 >> 2 = " + STRING(60 >> 2)); // 15

UTTER("");
UTTER("--- Conversions ---");

BIRTH charCode WITH 65;
UTTER("CHAR(" + charCode + ") = " + CHAR(charCode));

BIRTH charStr WITH "B";
UTTER("CODE("" + charStr + "") = " + STRING(CODE(charStr)));

BIRTH binVal WITH 10;
UTTER("BIN(" + binVal + ") = " + BIN(binVal));

BIRTH hexVal WITH 255;
UTTER("HEX(" + hexVal + ") = " + HEX(hexVal));

UTTER("");
UTTER("--- Byte Manipulation Example (simple XOR cipher) ---");

RITE encrypt(input, key) {
    BIRTH output WITH "";
    BIRTH i WITH 0;
    
    // Simple loop using recursion since no while loops in expressions
    RITE loop(idx) {
        SHOULD idx < LENGTH(input) {
            BIRTH char WITH SUBSTRING(input, idx, idx + 1);
            BIRTH c WITH CODE(char);
            BIRTH enc WITH c ^ key;
            
            // Format as hex for display
            BIRTH h WITH HEX(enc);
            SHOULD LENGTH(h) == 1 { h = "0" + h; }
            
            output = output + h + " ";
            
            import timer T(1ms);
            ~ATH(T) {} EXECUTE(loop(idx + 1));
        }
    }
    
    loop(0);
    BEQUEATH output;
}

BIRTH secret WITH "HELLO";
UTTER("Encrypting '" + secret + "' with key 42...");
// We need to wait for the async loop in encrypt... 
// Actually, rites are synchronous in their body execution, but the loop uses ~ATH which yields.
// So encrypt will return "output" before the loop finishes!
// This is a common pitfall. Let's rewrite loop to be synchronous or handle async return.
// Since we can't block in expression language without ~ATH, we can't easily make a sync loop.
// Instead, let's just do single character demo.

BIRTH c1 WITH CODE("H");
BIRTH k WITH 42;
UTTER("H (72) ^ 42 = " + STRING(c1 ^ k));
UTTER("Encrypted char: " + CHAR(c1 ^ k));
UTTER("Decrypted: " + CHAR((c1 ^ k) ^ k));

THIS.DIE();
