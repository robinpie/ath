<!--
  !~ATH Web Interpreter
  Copyright (C) 2026 Robin

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-->
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>!~ATH Interpreter</title>
<style>
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  background: #535353;
  font-family: "Courier New", Courier, monospace;
  font-size: 14px;
  color: #000;
  padding: 20px;
}

.container {
  max-width: 900px;
  margin: 0 auto;
}

.card {
  background: #eeeeee;
  border: 8px solid #c6c6c6;
  padding: 15px;
  margin-bottom: 15px;
}

h1 {
  font-size: 24px;
  font-weight: bold;
  text-align: center;
  margin-bottom: 5px;
}

.subtitle {
  text-align: center;
  font-size: 12px;
  margin-bottom: 10px;
}

.subtitle a {
  color: #000;
}

.editor-label {
  font-weight: bold;
  margin-bottom: 5px;
}

textarea {
  width: 100%;
  height: 300px;
  font-family: "Courier New", Courier, monospace;
  font-size: 13px;
  border: 2px solid #000;
  padding: 8px;
  resize: vertical;
  background: #fff;
}

textarea:focus {
  outline: none;
  border-color: #000;
}

.button-row {
  margin-top: 10px;
  text-align: center;
}

button {
  font-family: "Courier New", Courier, monospace;
  font-size: 14px;
  font-weight: bold;
  background: #fff;
  border: 2px solid #000;
  padding: 8px 20px;
  cursor: pointer;
  margin: 0 5px;
}

button:hover {
  background: #ddd;
}

button:active {
  background: #bbb;
}

button:disabled {
  background: #ccc;
  color: #666;
  cursor: not-allowed;
}

#output {
  width: 100%;
  height: 200px;
  font-family: "Courier New", Courier, monospace;
  font-size: 13px;
  border: 2px solid #000;
  padding: 8px;
  background: #fff;
  overflow-y: auto;
  white-space: pre-wrap;
  word-wrap: break-word;
}

.output-label {
  font-weight: bold;
  margin-bottom: 5px;
}

.input-section {
  margin-top: 15px;
}

.input-label {
  font-weight: bold;
  margin-bottom: 5px;
  font-size: 12px;
}

#input {
  width: 100%;
  height: auto;
  min-height: 28px;
  font-family: "Courier New", Courier, monospace;
  font-size: 13px;
  border: 2px solid #000;
  padding: 4px 8px;
  resize: none;
  background: #fff;
  overflow-y: hidden;
}

#input:focus {
  outline: none;
  border-color: #000;
}

.scry-input {
  width: 100%;
  height: 72px;
  font-family: "Courier New", Courier, monospace;
  font-size: 13px;
  border: 2px solid #000;
  padding: 4px 8px;
  resize: vertical;
  background: #fff;
  margin-bottom: 5px;
}

.scry-input:focus {
  outline: none;
  border-color: #000;
}

.status {
  text-align: center;
  margin-top: 10px;
  font-size: 12px;
}

.status.running {
  color: #006600;
}

.status.error {
  color: #cc0000;
}

.status.done {
  color: #000;
}

.examples {
  font-size: 12px;
}

.examples-label {
  font-weight: bold;
  margin-bottom: 10px;
}

.download {
  font-size: 12px;
}

.download a {
  color: #000;
}

.example-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
}

.example-buttons button {
  font-size: 12px;
  padding: 5px 10px;
}

.info {
  font-size: 11px;
  line-height: 1.4;
}

.info h2 {
  font-size: 14px;
  margin-bottom: 10px;
  border-bottom: 2px solid #000;
  padding-bottom: 5px;
}

.info h2 .spec-link {
  font-size: 11px;
  font-weight: normal;
}

.info h2 .spec-link a {
  color: #000;
}

.info h3 {
  font-size: 12px;
  margin-top: 12px;
  margin-bottom: 6px;
}

.info p {
  margin-bottom: 8px;
}

.info code {
  background: #fff;
  padding: 1px 4px;
  border: 1px solid #000;
}

.info pre {
  background: #fff;
  border: 1px solid #000;
  padding: 6px 8px;
  margin: 6px 0;
  overflow-x: auto;
}

.info .unavailable {
  color: #888;
  font-style: italic;
}
</style>
</head>
<body>

<div class="container">

<div class="card">
<h1>!~ATH INTERPRETER</h1>
<div class="subtitle">
an esoteric language where everything is about death
</div>
<div class="subtitle">
inspired by <em><a href="https://homestuck.com/">Homestuck</a></em>'s fictional ~ATH
</div>
<div class="subtitle">
<a href="https://github.com/robinpie/ath">view the GitHub and download the Python interpreter</a>
</div>
</div>

<div class="card">
<div class="editor-label">CODE:</div>
<textarea id="code" spellcheck="false" placeholder="Write !~ATH code here..."></textarea>

<div class="input-section">
<div class="input-label">INPUT for HEED(), one line per call:</div>
<textarea id="input" spellcheck="false" rows="1" placeholder="One line per HEED() call..."></textarea>
</div>

<div class="input-section">
<div class="input-label">INPUT for SCRY(VOID), one box per call):</div>
<div id="scry-container">
<textarea class="scry-input" spellcheck="false" placeholder="Content for SCRY(VOID)..."></textarea>
</div>
<div style="margin-top: 5px;">
<button onclick="addScryInput()" style="font-size: 11px; padding: 4px 8px;">+</button>
<button id="remove-scry-btn" onclick="removeScryInput()" style="font-size: 11px; padding: 4px 8px; display: none;">-</button>
</div>
</div>

<div class="button-row">
<button id="run-btn" onclick="runCode()">> RUN</button>
<button onclick="stopCode()">> STOP</button>
<button onclick="shareCode()">> SHARE</button>
</div>

<div class="status" id="status"></div>
</div>

<div class="card">
<div class="output-label">OUTPUT:</div>
<div id="output"></div>
</div>

<div class="card examples">
<div class="examples-label">EXAMPLE PROGRAMS:</div>
<div class="example-buttons">
<button onclick="loadExample('hello')">Hello World</button>
<button onclick="loadExample('countdown')">Countdown</button>
<button onclick="loadExample('fizzbuzz')">FizzBuzz</button>
<button onclick="loadExample('concurrent')">Concurrent Timers</button>
<button onclick="loadExample('factorial')">Factorial</button>
<button onclick="loadExample('arrays')">Arrays &amp; Maps</button>
<button onclick="loadExample('quine')">Quine</button>
<button onclick="loadExample('input')">Input Demo</button>
<button onclick="loadExample('scry')">SCRY Input</button>
<button onclick="loadExample('brainfuck')">Brainfuck</button>
</div>
</div>

<div class="card download">
<strong>DOWNLOAD:</strong> Run !~ATH programs locally with the Python interpreter (found on <a href="https://github.com/robinpie/ath">GitHub</a>). It includes process, connection, watcher entities and file I/O.
</div>

<div class="card info">
<h2>LANGUAGE REFERENCE <span class="spec-link">(<em><a href="/ath/!~ATH spec.md">full spec</a></em>)</span></h2>

<p>
<strong>!~ATH</strong> (pronounced "until death") is an esoteric programming language where
all control flow is predicated on waiting for things to die. Everything is about death. Loops wait
for entities to die. Computation happens in death callbacks. The language is
deliberately inconvenient.
</p>
<p>
Inspired by
the fictional ~ATH language from <em>Homestuck</em>.
</p>

<h3>ENTITIES</h3>
<p>
Entities are mortal things that can be waited upon. Each entity is either
<strong>alive</strong> or <strong>dead</strong>. Create entities with <code>import</code>:
</p>
<pre>import timer T(1s);        // dies after 1 second
import timer T2(500ms);    // dies after 500 milliseconds</pre>
<p>
<span class="unavailable">import process P("cmd");   // dies when process exits [NOT IN BROWSER]</span><br>
<span class="unavailable">import connection C("host", 80); // dies when connection closes [NOT IN BROWSER]</span><br>
<span class="unavailable">import watcher W("file.txt");    // dies when file is deleted [NOT IN BROWSER]</span>
</p>
<p>
<code>THIS</code> is an implicit entity representing the program itself.
Kill entities manually with <code>.DIE()</code>. The program ends when
<code>THIS.DIE();</code> is called.
</p>

<h3>~ATH LOOPS</h3>
<p>
The fundamental control structure. Waits for an entity to die, then runs the
EXECUTE clause:
</p>
<pre>import timer T(1s);
~ATH(T) {
} EXECUTE(UTTER("Timer died!"));
THIS.DIE();</pre>
<p>
Combine entities with <code>&amp;&amp;</code> (both must die), <code>||</code>
(either dies), or <code>!</code> (dies immediately when created):
</p>
<pre>~ATH(T1 &amp;&amp; T2) { } EXECUTE(...);  // wait for both
~ATH(T1 || T2) { } EXECUTE(...);  // wait for either
~ATH(!T) { } EXECUTE(...);        // runs immediately</pre>

<h3>BIFURCATION</h3>
<p>
Split execution into concurrent branches:
</p>
<pre>bifurcate THIS[LEFT, RIGHT];

~ATH(LEFT) {
    // code for left branch
} EXECUTE(VOID);

~ATH(RIGHT) {
    // code for right branch
} EXECUTE(VOID);

[LEFT, RIGHT].DIE();</pre>

<h3>VARIABLES</h3>
<pre>BIRTH x WITH 5;           // mutable variable
ENTOMB PI WITH 3.14159;   // constant (immutable)
x = x + 1;                // reassignment</pre>

<h3>DATA TYPES</h3>
<pre>42, -7                    // INTEGER
3.14, -0.5                // FLOAT
"hello\nworld"            // STRING (escapes: \\ \" \n \t)
ALIVE, DEAD               // BOOLEAN (truthy/falsy)
VOID                      // absence of value
[1, 2, 3]                 // ARRAY
{name: "Karkat", age: 6}  // MAP</pre>

<h3>OPERATORS</h3>
<pre>+ - * / %                     // arithmetic (/ is integer div for ints)
== != &lt; &gt; &lt;= &gt;=               // comparison
AND OR NOT                    // logical (short-circuit)
arr[0]  map["key"]  map.key   // indexing</pre>

<h3>CONTROL FLOW</h3>
<pre>SHOULD condition {
    // if truthy
} LEST {
    // else
}</pre>
<p>
<strong>No loops in the expression language.</strong> Use ~ATH for iteration:
</p>
<pre>RITE countdown(n) {
    SHOULD n &gt; 0 {
        UTTER(n);
        import timer T(1s);
        ~ATH(T) { } EXECUTE(countdown(n - 1));
    }
}
countdown(5);
THIS.DIE();</pre>

<h3>FUNCTIONS (RITES)</h3>
<pre>RITE add(a, b) {
    BEQUEATH a + b;       // return value
}
BIRTH sum WITH add(2, 3);</pre>

<h3>ERROR HANDLING</h3>
<pre>ATTEMPT {
    BIRTH x WITH PARSE_INT("bad");
} SALVAGE error {
    UTTER("Error: " + error);
}

CONDEMN "Something went wrong";  // throw error</pre>

<h3>BUILT-IN RITES</h3>
<p><strong>I/O:</strong></p>
<pre>UTTER("Hello", x);        // print (space-separated, newline appended)
BIRTH line WITH HEED();   // read line from input
BIRTH s WITH SCRY(VOID);  // read STDIN until EOF. in the Python interpreter, can also read files with SCRY("filename")</pre>
<p>
<span class="unavailable">INSCRIBE("file.txt", s)   // write file [NOT IN BROWSER]</span>
</p>

<p><strong>Type operations:</strong></p>
<pre>TYPEOF(x)                 // "INTEGER", "FLOAT", "STRING", etc.
LENGTH(arr), LENGTH(str)  // length of array or string
PARSE_INT("42")           // string to integer
PARSE_FLOAT("3.14")       // string to float
STRING(42)                // value to string
INT(3.7)                  // float to integer (truncates)
FLOAT(42)                 // integer to float</pre>

<p><strong>Array operations:</strong></p>
<pre>APPEND(arr, val)          // add to end (returns new array)
PREPEND(arr, val)         // add to start
SLICE(arr, start, end)    // subsequence
FIRST(arr), LAST(arr)     // first/last element
CONCAT(arr1, arr2)        // concatenate arrays</pre>

<p><strong>Map operations:</strong></p>
<pre>KEYS(map), VALUES(map)    // get keys/values as arrays
HAS(map, key)             // check if key exists
SET(map, key, val)        // set key (returns new map)
DELETE(map, key)          // remove key</pre>

<p><strong>String operations:</strong></p>
<pre>SPLIT("a,b,c", ",")       // split to array
JOIN(arr, ",")            // join array to string
SUBSTRING(s, start, end)  // extract substring
UPPERCASE(s), LOWERCASE(s), TRIM(s)
REPLACE(s, old, new)      // replace all occurrences</pre>

<p><strong>Utility:</strong></p>
<pre>RANDOM()                  // random float 0 to 1
RANDOM_INT(min, max)      // random integer in range
TIME()                    // Unix timestamp in ms</pre>
</div>

<div class="card" style="font-size: 10px; text-align: center; color: #666; margin-top: 15px;">
  &copy; 2026 Robin. Licensed under the <a href="https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt" style="color: #666;">GNU GPL v2</a>.
</div>

</div>

<script src="tildeath.js"></script>
<script>
var currentRuntime = null;
var isRunning = false;

var examples = {
  hello: `// Hello world in !~ATH with timer example
import timer T(1ms);

~ATH(T) {
} EXECUTE(UTTER("Hello, world!"));

THIS.DIE();`,

  countdown: `// Countdown using chained timers
RITE countdown(n) {
    SHOULD n > 0 {
        UTTER(n);
        import timer T(1s);
        ~ATH(T) {
        } EXECUTE(countdown(n - 1));
    } LEST {
        UTTER("Liftoff!");
    }
}

countdown(5);
THIS.DIE();`,

  fizzbuzz: `// FizzBuzz using recursion with timer chains
RITE fizzbuzz(n, max) {
    SHOULD n <= max {
        SHOULD n % 15 == 0 {
            UTTER("FizzBuzz");
        } LEST SHOULD n % 3 == 0 {
            UTTER("Fizz");
        } LEST SHOULD n % 5 == 0 {
            UTTER("Buzz");
        } LEST {
            UTTER(n);
        }

        import timer T(1ms);
        ~ATH(!T) {
        } EXECUTE(fizzbuzz(n + 1, max));
    }
}

fizzbuzz(1, 50);
THIS.DIE();`,

  concurrent: `// Concurrent execution with bifurcation
bifurcate THIS[LEFT, RIGHT];

~ATH(LEFT) {
    import timer T1(1s);
    ~ATH(T1) {
    } EXECUTE(UTTER("Left: 1 second"));

    import timer T2(1s);
    ~ATH(T2) {
    } EXECUTE(UTTER("Left: 2 seconds"));
} EXECUTE(UTTER("Left branch complete"));

~ATH(RIGHT) {
    import timer T3(1500ms);
    ~ATH(T3) {
    } EXECUTE(UTTER("Right: 1.5 seconds"));
} EXECUTE(UTTER("Right branch complete"));

[LEFT, RIGHT].DIE();`,

  factorial: `// Recursive factorial
RITE factorial(n) {
    SHOULD n <= 1 {
        BEQUEATH 1;
    }
    BEQUEATH n * factorial(n - 1);
}

BIRTH result WITH factorial(10);
UTTER("10! = " + STRING(result));

THIS.DIE();`,

  arrays: `// Working with arrays and maps
BIRTH arr WITH [1, 2, 3, 4, 5];
UTTER("Array: " + STRING(arr));
UTTER("Length: " + STRING(LENGTH(arr)));
UTTER("First: " + STRING(FIRST(arr)));
UTTER("Last: " + STRING(LAST(arr)));

arr = APPEND(arr, 6);
UTTER("After append: " + STRING(arr));

BIRTH person WITH {name: "Karkat", age: 6, title: "Knight of Blood"};
UTTER("Map: " + STRING(person));
UTTER("Name: " + person.name);
UTTER("Keys: " + STRING(KEYS(person)));

THIS.DIE();`,

  input: `// Demo of HEED() for reading input
// Put some lines in the INPUT box below, then run!

UTTER("What is your name?");
BIRTH name WITH HEED();
UTTER("Hello, " + name + "!");

UTTER("What is your favorite number?");
BIRTH numStr WITH HEED();
BIRTH num WITH PARSE_INT(numStr);
UTTER("Your number doubled is: " + STRING(num * 2));

THIS.DIE();`,

  scry: `// Reading from STDIN using SCRY(VOID)
// Add text to the SCRY input boxes below!
// Each SCRY(VOID) call consumes one input box.

UTTER("Reading first SCRY input...");
BIRTH content1 WITH SCRY(VOID);
UTTER("First content length: " + STRING(LENGTH(content1)));
UTTER("First content preview: " + SUBSTRING(content1, 0, 20) + "...");

UTTER("Reading second SCRY input...");
BIRTH content2 WITH SCRY(VOID);
UTTER("Second content length: " + STRING(LENGTH(content2)));

THIS.DIE();`,

  quine: `BIRTH q WITH "BIRTH q WITH PLACEHOLDER; BIRTH e WITH REPLACE(REPLACE(q, \\"\\\\\\\\\\", \\"\\\\\\\\\\\\\\\\\\"), \\"\\\\\\"\\", \\"\\\\\\\\\\\\\\"\\"\\"); UTTER(REPLACE(q, \\"PLACE\\" + \\"HOLDER\\", \\"\\\\\\"\\" + e + \\"\\\\\\"\\")); THIS.DIE();"; BIRTH e WITH REPLACE(REPLACE(q, "\\\\", "\\\\\\\\"), "\\"", "\\\\\\""); UTTER(REPLACE(q, "PLACE" + "HOLDER", "\\"" + e + "\\"")); THIS.DIE();`,

  brainfuck: `// An interpreter for the Brainfuck esoteric programming language.\n//\n// Takes two inputs, where:\n//   - the first input is the string of Brainfuck commands (+-[]<>.,)\n//   - the second input is the string of ASCII input to the program.\n//\n// The interpreter outputs the result via UTTER when execution completes.\n// =============================================================================\n\n// --- ASCII Lookup Tables ---\n// !~ATH has no built-in chr/ord, so we need explicit mappings\n\nENTOMB CHAR_TO_CODE WITH {\n    "\\n": 10, "\\t": 9,\n    " ": 32, "!": 33, "\\"": 34, "#": 35, "$": 36, "%": 37, "&": 38, "'": 39,\n    "(": 40, ")": 41, "*": 42, "+": 43, ",": 44, "-": 45, ".": 46, "/": 47,\n    "0": 48, "1": 49, "2": 50, "3": 51, "4": 52, "5": 53, "6": 54, "7": 55,\n    "8": 56, "9": 57, ":": 58, ";": 59, "<": 60, "=": 61, ">": 62, "?": 63,\n    "@": 64, "A": 65, "B": 66, "C": 67, "D": 68, "E": 69, "F": 70, "G": 71,\n    "H": 72, "I": 73, "J": 74, "K": 75, "L": 76, "M": 77, "N": 78, "O": 79,\n    "P": 80, "Q": 81, "R": 82, "S": 83, "T": 84, "U": 85, "V": 86, "W": 87,\n    "X": 88, "Y": 89, "Z": 90, "[": 91, "\\\\": 92, "]": 93, "^": 94, "_": 95,\n    "\`": 96, "a": 97, "b": 98, "c": 99, "d": 100, "e": 101, "f": 102, "g": 103,\n    "h": 104, "i": 105, "j": 106, "k": 107, "l": 108, "m": 109, "n": 110, "o": 111,\n    "p": 112, "q": 113, "r": 114, "s": 115, "t": 116, "u": 117, "v": 118, "w": 119,\n    "x": 120, "y": 121, "z": 122, "{": 123, "|": 124, "}": 125, "~": 126\n};\n\n// Code to character mapping (keys must be strings for map lookup)\nENTOMB CODE_TO_CHAR WITH {\n    "10": "\\n", "9": "\\t",\n    "32": " ", "33": "!", "34": "\\"", "35": "#", "36": "$", "37": "%", "38": "&", "39": "'",\n    "40": "(", "41": ")", "42": "*", "43": "+", "44": ",", "45": "-", "46": ".", "47": "/",\n    "48": "0", "49": "1", "50": "2", "51": "3", "52": "4", "53": "5", "54": "6", "55": "7",\n    "56": "8", "57": "9", "58": ":", "59": ";", "60": "<", "61": "=", "62": ">", "63": "?",\n    "64": "@", "65": "A", "66": "B", "67": "C", "68": "D", "69": "E", "70": "F", "71": "G",\n    "72": "H", "73": "I", "74": "J", "75": "K", "76": "L", "77": "M", "78": "N", "79": "O",\n    "80": "P", "81": "Q", "82": "R", "83": "S", "84": "T", "85": "U", "86": "V", "87": "W",\n    "88": "X", "89": "Y", "90": "Z", "91": "[", "92": "\\\\", "93": "]", "94": "^", "95": "_",\n    "96": "\`", "97": "a", "98": "b", "99": "c", "100": "d", "101": "e", "102": "f", "103": "g",\n    "104": "h", "105": "i", "106": "j", "107": "k", "108": "l", "109": "m", "110": "n", "111": "o",\n    "112": "p", "113": "q", "114": "r", "115": "s", "116": "t", "117": "u", "118": "v", "119": "w",\n    "120": "x", "121": "y", "122": "z", "123": "{", "124": "|", "125": "}", "126": "~"\n};\n\n// --- Global State ---\n// All interpreter state is stored globally so async operations can access it\n\nBIRTH G_code WITH "";\nBIRTH G_input WITH "";\nBIRTH G_tape WITH [];\nBIRTH G_ptr WITH 0;\nBIRTH G_ip WITH 0;\nBIRTH G_inputPos WITH 0;\nBIRTH G_output WITH "";\nBIRTH G_brackets WITH {};\nBIRTH G_bracketStack WITH [];\nBIRTH G_bracketIdx WITH 0;\nBIRTH G_tapeChunksLeft WITH 0;\n\n// --- Tape Operations ---\n// Arrays are immutable in !~ATH, so we need to create new arrays for modifications\n\nRITE setCell(tape, idx, val) {\n    BEQUEATH CONCAT(\n        CONCAT(SLICE(tape, 0, idx), [val]),\n        SLICE(tape, idx + 1, LENGTH(tape))\n    );\n}\n\nRITE incCell(tape, ptr) {\n    BIRTH val WITH tape[ptr];\n    BIRTH newVal WITH (val + 1) % 256;\n    BEQUEATH setCell(tape, ptr, newVal);\n}\n\nRITE decCell(tape, ptr) {\n    BIRTH val WITH tape[ptr];\n    BIRTH newVal WITH (val + 255) % 256;\n    BEQUEATH setCell(tape, ptr, newVal);\n}\n\n// --- Tape Initialization ---\n// Build tape in chunks using timer-chained recursion to avoid stack overflow\n\nENTOMB TAPE_CHUNK WITH [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\nRITE buildTapeStep() {\n    SHOULD G_tapeChunksLeft > 0 {\n        G_tape = CONCAT(G_tape, TAPE_CHUNK);\n        G_tapeChunksLeft = G_tapeChunksLeft - 1;\n        import timer T(1);\n        ~ATH(!T) { } EXECUTE(buildTapeStep());\n    } LEST {\n        // Tape complete, start bracket building\n        buildBracketsStep();\n    }\n}\n\n// --- Bracket Matching (Async) ---\n// Pre-compute matching brackets using timer-chained recursion\n\nRITE buildBracketsStep() {\n    BIRTH len WITH LENGTH(G_code);\n\n    SHOULD G_bracketIdx < len {\n        BIRTH char WITH G_code[G_bracketIdx];\n\n        SHOULD char == "[" {\n            G_bracketStack = APPEND(G_bracketStack, G_bracketIdx);\n        } LEST SHOULD char == "]" {\n            SHOULD LENGTH(G_bracketStack) == 0 {\n                CONDEMN "Unmatched ] at position " + STRING(G_bracketIdx);\n            }\n            BIRTH openPos WITH LAST(G_bracketStack);\n            G_bracketStack = SLICE(G_bracketStack, 0, LENGTH(G_bracketStack) - 1);\n            G_brackets = SET(G_brackets, STRING(openPos), G_bracketIdx);\n            G_brackets = SET(G_brackets, STRING(G_bracketIdx), openPos);\n        }\n\n        G_bracketIdx = G_bracketIdx + 1;\n\n        import timer T(1);\n        ~ATH(!T) { } EXECUTE(buildBracketsStep());\n    } LEST {\n        SHOULD LENGTH(G_bracketStack) > 0 {\n            CONDEMN "Unmatched [ at position " + STRING(FIRST(G_bracketStack));\n        }\n        // Bracket map complete, start execution\n        startExecution();\n    }\n}\n\n// --- Core Execution ---\n// Main execution loop using timer-chained recursion\n\nRITE startExecution() {\n    G_ptr = 0;\n    G_ip = 0;\n    G_inputPos = 0;\n    G_output = "";\n    runStep();\n}\n\nRITE runStep() {\n    BIRTH len WITH LENGTH(G_code);\n\n    // Check if execution is complete\n    SHOULD G_ip >= len {\n        UTTER(G_output);\n        BEQUEATH VOID;\n    }\n\n    BIRTH cmd WITH G_code[G_ip];\n\n    SHOULD cmd == "+" {\n        G_tape = incCell(G_tape, G_ptr);\n        G_ip = G_ip + 1;\n    } LEST SHOULD cmd == "-" {\n        G_tape = decCell(G_tape, G_ptr);\n        G_ip = G_ip + 1;\n    } LEST SHOULD cmd == ">" {\n        G_ptr = G_ptr + 1;\n        G_ip = G_ip + 1;\n    } LEST SHOULD cmd == "<" {\n        G_ptr = G_ptr - 1;\n        G_ip = G_ip + 1;\n    } LEST SHOULD cmd == "." {\n        BIRTH cellVal WITH G_tape[G_ptr];\n        BIRTH key WITH STRING(cellVal);\n        SHOULD HAS(CODE_TO_CHAR, key) {\n            G_output = G_output + CODE_TO_CHAR[key];\n        } LEST {\n            G_output = G_output + "?";\n        }\n        G_ip = G_ip + 1;\n    } LEST SHOULD cmd == "," {\n        SHOULD G_inputPos < LENGTH(G_input) {\n            BIRTH inputChar WITH G_input[G_inputPos];\n            SHOULD HAS(CHAR_TO_CODE, inputChar) {\n                G_tape = setCell(G_tape, G_ptr, CHAR_TO_CODE[inputChar]);\n            } LEST {\n                G_tape = setCell(G_tape, G_ptr, 0);\n            }\n            G_inputPos = G_inputPos + 1;\n        } LEST {\n            G_tape = setCell(G_tape, G_ptr, 0);\n        }\n        G_ip = G_ip + 1;\n    } LEST SHOULD cmd == "[" {\n        SHOULD G_tape[G_ptr] == 0 {\n            G_ip = G_brackets[STRING(G_ip)] + 1;\n        } LEST {\n            G_ip = G_ip + 1;\n        }\n    } LEST SHOULD cmd == "]" {\n        SHOULD G_tape[G_ptr] != 0 {\n            G_ip = G_brackets[STRING(G_ip)] + 1;\n        } LEST {\n            G_ip = G_ip + 1;\n        }\n    } LEST {\n        // Unknown character, skip\n        G_ip = G_ip + 1;\n    }\n\n    // Timer-chain to next step (prevents stack overflow)\n    import timer T(1);\n    ~ATH(!T) { } EXECUTE(runStep());\n}\n\n// --- Main Entry Point ---\n\nRITE runBrainfuck(code, input) {\n    // Initialize global state\n    G_code = code;\n    G_input = input;\n    G_tape = [];\n    G_brackets = {};\n    G_bracketStack = [];\n    G_bracketIdx = 0;\n\n    // Build tape (300 chunks of 100 = 30000 cells)\n    G_tapeChunksLeft = 300;\n    buildTapeStep();\n}\n\n// Read brainfuck code and input from HEED()\nBIRTH code WITH HEED();\nBIRTH input WITH HEED();\nrunBrainfuck(code, input);\n\nTHIS.DIE();`
};

var exampleInputs = {
  input: "Karkat\n612",
  brainfuck: ",[.,]\nHello, World!",
  scry: ["This is the first file content.", "And this is the second."]
};

function autoExpand(el) {
    el.style.height = 'auto';
    el.style.height = el.scrollHeight + 'px';
}

document.getElementById('input').addEventListener('input', function() {
    autoExpand(this);
});

function loadExample(name) {
  document.getElementById('code').value = examples[name];
  
  if (name === 'scry') {
      document.getElementById('input').value = '';
      resetScryInputs();
      var inputs = exampleInputs[name];
      if (inputs && inputs.length > 0) {
          // Set first box
          document.querySelector('.scry-input').value = inputs[0];
          // Add subsequent boxes
          for (var i = 1; i < inputs.length; i++) {
              addScryInput(inputs[i]);
          }
      }
  } else {
      document.getElementById('input').value = exampleInputs[name] || '';
      resetScryInputs();
  }

  autoExpand(document.getElementById('input'));
  clearOutput();
}

function updateRemoveScryButton() {
    var container = document.getElementById('scry-container');
    var inputs = container.getElementsByClassName('scry-input');
    var btn = document.getElementById('remove-scry-btn');
    if (inputs.length > 1) {
        btn.style.display = 'inline-block';
    } else {
        btn.style.display = 'none';
    }
}

function addScryInput(value) {
    var container = document.getElementById('scry-container');
    var ta = document.createElement('textarea');
    ta.className = 'scry-input';
    ta.spellcheck = false;
    ta.placeholder = 'Content for SCRY(VOID)...';
    if (value) ta.value = value;
    container.appendChild(ta);
    updateRemoveScryButton();
}

function removeScryInput() {
    var container = document.getElementById('scry-container');
    var inputs = container.getElementsByClassName('scry-input');
    if (inputs.length > 1) {
        container.removeChild(inputs[inputs.length - 1]);
    }
    updateRemoveScryButton();
}

function resetScryInputs() {
    var container = document.getElementById('scry-container');
    container.innerHTML = '<textarea class="scry-input" spellcheck="false" placeholder="Content for SCRY(VOID)..."></textarea>';
    updateRemoveScryButton();
}

function appendOutput(text) {
  var output = document.getElementById('output');
  output.textContent += text + '\n';
  output.scrollTop = output.scrollHeight;
}

function clearOutput() {
  document.getElementById('output').textContent = '';
  document.getElementById('status').textContent = '';
  document.getElementById('status').className = 'status';
}

function setStatus(text, type) {
  var status = document.getElementById('status');
  status.textContent = text;
  status.className = 'status ' + type;
}

function stopCode() {
  if (currentRuntime) {
    // Can't truly stop async code, but we can ignore further output
    currentRuntime = null;
    isRunning = false;
    document.getElementById('run-btn').disabled = false;
    setStatus('Stopped.', 'done');
  }
}

async function runCode() {
  if (isRunning) return;

  clearOutput();
  isRunning = true;
  document.getElementById('run-btn').disabled = true;
  setStatus('Running...', 'running');

  var code = document.getElementById('code').value;
  var inputText = document.getElementById('input').value;
  var inputLines = inputText ? inputText.split('\n') : [];
  
  var scryInputs = [];
  var scryElements = document.getElementsByClassName('scry-input');
  for (var i = 0; i < scryElements.length; i++) {
      scryInputs.push(scryElements[i].value);
  }
  
  var runtimeId = {};
  currentRuntime = runtimeId;

  var runtime = new TildeAth({
    onOutput: function(text) {
      if (currentRuntime === runtimeId) {
        appendOutput(text);
      }
    },
    inputQueue: inputLines,
    scryQueue: scryInputs
  });

  try {
    await runtime.run(code);
    if (currentRuntime === runtimeId) {
      setStatus('Done.', 'done');
    }
  } catch (e) {
    if (currentRuntime === runtimeId) {
      appendOutput('ERROR: ' + e.message);
      setStatus('Error!', 'error');
    }
  } finally {
    if (currentRuntime === runtimeId) {
      isRunning = false;
      document.getElementById('run-btn').disabled = false;
      currentRuntime = null;
    }
  }
}

// Base64 encoding/decoding with Unicode support
function utoa(str) {
  return btoa(unescape(encodeURIComponent(str)));
}

function atou(str) {
  return decodeURIComponent(escape(atob(str)));
}

function shareCode() {
  var code = document.getElementById('code').value;
  var input = document.getElementById('input').value;

  var params = new URLSearchParams();
  if (code) params.set('code', utoa(code));
  if (input) params.set('input', utoa(input));

  // Collect SCRY inputs
  var scryInputs = [];
  var scryElements = document.getElementsByClassName('scry-input');
  var hasScryContent = false;
  for (var i = 0; i < scryElements.length; i++) {
    var val = scryElements[i].value;
    scryInputs.push(val);
    if (val) hasScryContent = true;
  }
  
  // Only share if there's content or multiple boxes
  if (hasScryContent || scryInputs.length > 1) {
    params.set('scry', utoa(JSON.stringify(scryInputs)));
  }

  var url = window.location.origin + window.location.pathname;
  if (params.toString()) {
    url += '?' + params.toString();
  }

  // Copy to clipboard
  navigator.clipboard.writeText(url).then(function() {
    setStatus('Link copied to clipboard!', 'done');
  }).catch(function() {
    // Fallback: show the URL
    prompt('Copy this link:', url);
  });
}

// Load from URL on page load
(function() {
  var params = new URLSearchParams(window.location.search);
  var code = params.get('code');
  var input = params.get('input');
  var scry = params.get('scry');

  if (code) {
    try {
      document.getElementById('code').value = atou(code);
    } catch (e) {}
  }
  if (input) {
    try {
      document.getElementById('input').value = atou(input);
      autoExpand(document.getElementById('input'));
    } catch (e) {}
  }
  if (scry) {
    try {
      var scryData = JSON.parse(atou(scry));
      if (Array.isArray(scryData) && scryData.length > 0) {
        resetScryInputs();
        document.querySelector('.scry-input').value = scryData[0];
        for (var i = 1; i < scryData.length; i++) {
          addScryInput(scryData[i]);
        }
      }
    } catch (e) {}
  }
})();
</script>

</body>
</html>
